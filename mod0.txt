CSCI 382 | ALGORITHMS | MOD0

1. How many times do you have to repeatedly halve 32 in order to reach 1?
What about 8192? Consider the function which given an input n, outputs
the number of times n can be repeatedly halved before falling below 1.
What is the common mathematical name for this function?

32/2 = 16
       16/2 = 8
	      8/2 = 4
		    4/2 = 2
		          2/2 = 1
						  
One must half 32 five times to get one. If we generalize this function to 
the halvings required to reach one or less, it is identical to the floor 
of log base 2 of n, which can be expressed as $lg(n)$. Generally, this sort 
of thing is a logarithm.


2. For each of the following, answer with the best (smallest) upper bound 
from this list: O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n). Give a
brief justification for each.

a. Let's say we've a depth-n balanced binary tree. The maximum amount of total 
nodes doubles for each new layer. Thus, the asymptotic growth rate is O(2^n).

b. On the other hand, the depth of a binary tree with n nodes is the 
smallest number x such that $2^x > n$. This is given by the floor of $lg(n)$,
and so this is O(log(n)).

c. How about a general tree? How many edges on them? Other than the root node,
each new node adds one new edge, connecting it to a parent. Thus, the number 
of edges of an n-node tree is O(n).

d. An n-node list being mergesorted gets did to it this:

(citation me @ https://brimstonetrader.github.io/archive/sort)

> mergeSort :: [Int] -> [Int]
> mergeSort  []    = []
> mergeSort  [x]   = [x]
> mergeSort  [x,y] = case (x>y) of 
>   True  -> [y,x]
>   False -> [x,y]
> mergeSort  list  = collate (mergeSort a) (mergeSort b)
>   where    (a,b) = splitAt ((length list) `div` 2) list
	
> collate :: [Int] -> [Int] -> [Int]
> collate    as     []  = as
> collate (a:as) (b:bs) = if a>b 
>                           then b:(collate (a:as) bs)
>                           else a:(collate as (b:bs))

mergeSort gets called on the order of n times, and 
collate gets called on the order of log(n) times for each. 
Thus, the asymptotic growth of the algorithm is O(nlog(n)).

e. Consider the number of distinct subsets of an n-item set. 
It is 2^n. Each item can either be in or not in the subset, and
so each new item doubles the total number of distinct subsets.
It's O(2^n).

f. The number of bits needed to represent a number in binary is
the floor of lg(n). That's O(log(n)).

g. Now we want the closest pair of points among n points in space.
In other words, given n tuples [(x_1,y_1), ... (x_n,y_n)], we want 
to find the numbers a and b such that (x_b - x_a)^2 + (y_b - y_a)^2 
is minimized for all integer values 1 <= a < b <= n. The brute force
approach, of listing all such pairs, requires O(n^2) such checks.

h. Here's a binary heap. To insert an element, one must switch on 
the order of log(n) elements to maintain the heap's structure. Thus, 
inserting n elements is O(nlog(n)).

i. Let's say we've a sorted n-element array called list. Finding the 
second largest element is as simple as list[n-2], which takes constant
time, making the operation O(1).

j. Now we want the second largest number of an unsorted list. This can
be done by 

> secondLargest :: [Int] -> Int
> secondLargest (a:b:list) = sL2 (if a>b then (a,b) else (b,a)) list

> sL2 :: (Int,Int) -> [Int] -> Int
> sL2 (a,b) []     = b
> sL2 (a,b) (c:cs) = sL2 (if c>b 
>		            then if c>a 
>                                  then (c,a)
>                                  else (a,c)
>                           else (a,b)) cs

This algorithm calls sL2 n times, so the problem takes O(n) time.


3. Let p_n defined on n >= 0.
       p_0 = 0
       p_1 =       2(p_0) + 1                =  2p_0 + 1
       p_2 =     2(2(p_0) + 1) + 1           =  4p_0 + 2 + 1
       p_3 =   2(2(2(p_0) + 1) + 1) + 1      =  8p_0 + 4 + 2 + 1
       p_4 = 2(2(2(2(p_0) + 1) + 1) + 1) + 1 = 16p_0 + 8 + 4 + 2 + 1
     
       ...
   
       p_n = $2p_{n-1} + 1$

Let our number n be in base 10, and let us shift n to binary and call 
that number b. Arbitrarily let n=5, b=101.

The action of multiplying n by two is the same as concatenating a zero 
to the end of b. 

The action of adding one to a binary number is the same as flipping the 
end bit from zero to one if the number is initially even, or something 
else if it's odd. We don't need to know precisely what that is, because 
2x for any integer x is always even.

p_1 = 1 in both binary and base-10. By induction, we can conclude that 
p_n is represented in binary by n successive ones.
	   
Therefore, each term p_n consists of the sum Σ_{x=0}^{n-1} 2^x. This is 
the binary number generated by concatenation of n ones, better known as

       p_n = 2^n - 1	
	
4. Write an algorithm to find the smallest integer in a binary tree, 
returning +∞ if the tree is empty.

> treeMin :: Tree -> Int
> treeMin NULL = ∞
> treeMin T    = if T.left == NULL
>                  then T.value
>                  else treeMin T.left


2.5 hours to do, 

 .5 hours to check and typeset.